{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/verify-payment-proof.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview AI flow for automatically verifying payment proofs uploaded by users.\n *\n * - verifyPaymentProof - A function that handles the payment proof verification process.\n * - VerifyPaymentProofInput - The input type for the verifyPaymentProof function.\n * - VerifyPaymentProofOutput - The return type for the verifyPaymentProof function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst VerifyPaymentProofInputSchema = z.object({\n  paymentProofDataUri: z\n    .string()\n    .describe(\n      \"The payment proof image, which can be a public URL or a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'.\"\n    ),\n  expectedAmount: z.number().describe('The expected payment amount.'),\n  orderId: z.string().describe('The ID of the order associated with the payment.'),\n});\nexport type VerifyPaymentProofInput = z.infer<typeof VerifyPaymentProofInputSchema>;\n\nconst VerifyPaymentProofOutputSchema = z.object({\n  isVerified: z.boolean().describe('Whether the payment proof is verified or not.'),\n  reason: z.string().describe('The reason for the verification result.'),\n});\nexport type VerifyPaymentProofOutput = z.infer<typeof VerifyPaymentProofOutputSchema>;\n\nexport async function verifyPaymentProof(input: VerifyPaymentProofInput): Promise<VerifyPaymentProofOutput> {\n  return verifyPaymentProofFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'verifyPaymentProofPrompt',\n  input: {schema: VerifyPaymentProofInputSchema},\n  output: {schema: VerifyPaymentProofOutputSchema},\n  prompt: `You are an expert payment verification specialist.\n\nYou will analyze the provided payment proof image and determine if it is a valid proof of payment for the specified amount and order.\n\nThe user has paid {{expectedAmount}}. Look for this amount in the proof.\nThe Order ID is {{orderId}}. This may or may not be present in the proof.\n\nConsider the following factors:\n- Clarity and legibility of the image.\n- Presence of key information such as amount paid, date, and transaction ID.\n- Consistency of the information with the expected amount.\n- Any obvious signs of tampering or fraud.\n\nBased on your analysis, set the isVerified output field to true if the payment proof is valid, and false otherwise. Provide a detailed reason for your decision in the reason output field. If you approve, the reason should be \"Payment confirmed via AI.\". If you reject, explain why (e.g., \"Amount does not match expected value.\", \"Image is blurry.\").\n\nPayment Proof Image: {{media url=paymentProofDataUri}}\nExpected Amount: {{{expectedAmount}}}\nOrder ID: {{{orderId}}}`,\n});\n\nconst verifyPaymentProofFlow = ai.defineFlow(\n  {\n    name: 'verifyPaymentProofFlow',\n    inputSchema: VerifyPaymentProofInputSchema,\n    outputSchema: VerifyPaymentProofOutputSchema,\n  },\n  async input => {\n    // Add a small delay to simulate processing, as local verification can be too fast.\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    try {\n      const {output} = await prompt(input);\n      if (!output) {\n        return {\n          isVerified: false,\n          reason: 'AI model did not return a valid response.'\n        }\n      }\n      return output;\n    } catch (e) {\n       console.error(\"AI verification flow failed\", e);\n       return {\n         isVerified: false,\n         reason: 'An error occurred during AI processing.'\n       }\n    }\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,qBAAqB,uIAAA,CAAA,IAAC,CACnB,MAAM,GACN,QAAQ,CACP;IAEJ,gBAAgB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACpC,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B;AAGA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,YAAY,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IACjC,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAGO,eAAe,mBAAmB,KAA8B;IACrE,OAAO,uBAAuB;AAChC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAA6B;IAC7C,QAAQ;QAAC,QAAQ;IAA8B;IAC/C,QAAQ,CAAC;;;;;;;;;;;;;;;;;uBAiBY,CAAC;AACxB;AAEA,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,mFAAmF;IACnF,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;IAEjD,IAAI;QACF,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;QAC9B,IAAI,CAAC,QAAQ;YACX,OAAO;gBACL,YAAY;gBACZ,QAAQ;YACV;QACF;QACA,OAAO;IACT,EAAE,OAAO,GAAG;QACT,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YACL,YAAY;YACZ,QAAQ;QACV;IACH;AACF;;;IAtDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/schema.ts"],"sourcesContent":["\nimport { pgTable, serial, text, varchar, integer, timestamp, boolean } from 'drizzle-orm/pg-core';\n\nexport const bookings = pgTable('bookings', {\n  id: serial('id').primaryKey(),\n  orderId: varchar('order_id', { length: 255 }).unique().notNull(),\n  ownerFullName: varchar('owner_full_name', { length: 255 }),\n  ownerMobile: varchar('owner_mobile', { length: 20 }),\n  ownerEmail: varchar('owner_email', { length: 255 }),\n  ownerAadhaar: varchar('owner_aadhaar', { length: 20 }),\n  ownerAddress: text('owner_address'),\n  ownerState: varchar('owner_state', { length: 100 }),\n  ownerPincode: varchar('owner_pincode', { length: 10 }),\n  vehicleRegistrationNumber: varchar('vehicle_registration_number', { length: 50 }),\n  engineNumber: varchar('engine_number', { length: 100 }),\n  chassisNumber: varchar('chassis_number', { length: 100 }),\n  vehicleMake: varchar('vehicle_make', { length: 100 }),\n  vehicleModel: varchar('vehicle_model', { length: 100 }),\n  manufacturingYear: varchar('manufacturing_year', { length: 4 }),\n  vehicleCategory: varchar('vehicle_category', { length: 100 }),\n  amount: integer('amount'),\n  status: varchar('status', { length: 50 }).default('pending'),\n  paymentProof: text('payment_proof'),\n  verificationReason: text('verification_reason'),\n  createdAt: timestamp('created_at').defaultNow(),\n  updatedAt: timestamp('updated_at').defaultNow(),\n});\n    \nexport const contacts = pgTable('contacts', {\n    id: serial('id').primaryKey(),\n    firstName: varchar('first_name', { length: 255 }),\n    lastName: varchar('last_name', { length: 255 }),\n    email: varchar('email', { length: 255 }),\n    message: text('message'),\n    createdAt: timestamp('created_at').defaultNow(),\n});\n"],"names":[],"mappings":";;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEO,MAAM,WAAW,CAAA,GAAA,qJAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IAC1C,IAAI,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE,MAAM,UAAU;IAC3B,SAAS,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,YAAY;QAAE,QAAQ;IAAI,GAAG,MAAM,GAAG,OAAO;IAC9D,eAAe,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,mBAAmB;QAAE,QAAQ;IAAI;IACxD,aAAa,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,gBAAgB;QAAE,QAAQ;IAAG;IAClD,YAAY,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,eAAe;QAAE,QAAQ;IAAI;IACjD,cAAc,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,iBAAiB;QAAE,QAAQ;IAAG;IACpD,cAAc,CAAA,GAAA,+JAAA,CAAA,OAAI,AAAD,EAAE;IACnB,YAAY,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,eAAe;QAAE,QAAQ;IAAI;IACjD,cAAc,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,iBAAiB;QAAE,QAAQ;IAAG;IACpD,2BAA2B,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,+BAA+B;QAAE,QAAQ;IAAG;IAC/E,cAAc,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,iBAAiB;QAAE,QAAQ;IAAI;IACrD,eAAe,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,kBAAkB;QAAE,QAAQ;IAAI;IACvD,aAAa,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,gBAAgB;QAAE,QAAQ;IAAI;IACnD,cAAc,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,iBAAiB;QAAE,QAAQ;IAAI;IACrD,mBAAmB,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,sBAAsB;QAAE,QAAQ;IAAE;IAC7D,iBAAiB,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,oBAAoB;QAAE,QAAQ;IAAI;IAC3D,QAAQ,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE;IAChB,QAAQ,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,UAAU;QAAE,QAAQ;IAAG,GAAG,OAAO,CAAC;IAClD,cAAc,CAAA,GAAA,+JAAA,CAAA,OAAI,AAAD,EAAE;IACnB,oBAAoB,CAAA,GAAA,+JAAA,CAAA,OAAI,AAAD,EAAE;IACzB,WAAW,CAAA,GAAA,oKAAA,CAAA,YAAS,AAAD,EAAE,cAAc,UAAU;IAC7C,WAAW,CAAA,GAAA,oKAAA,CAAA,YAAS,AAAD,EAAE,cAAc,UAAU;AAC/C;AAEO,MAAM,WAAW,CAAA,GAAA,qJAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IACxC,IAAI,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE,MAAM,UAAU;IAC3B,WAAW,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,cAAc;QAAE,QAAQ;IAAI;IAC/C,UAAU,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,aAAa;QAAE,QAAQ;IAAI;IAC7C,OAAO,CAAA,GAAA,kKAAA,CAAA,UAAO,AAAD,EAAE,SAAS;QAAE,QAAQ;IAAI;IACtC,SAAS,CAAA,GAAA,+JAAA,CAAA,OAAI,AAAD,EAAE;IACd,WAAW,CAAA,GAAA,oKAAA,CAAA,YAAS,AAAD,EAAE,cAAc,UAAU;AACjD","debugId":null}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/db.ts"],"sourcesContent":["\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport { neon } from '@neondatabase/serverless';\nimport * as schema from './schema';\n\nconst sql = neon(process.env.DATABASE_URL!);\nexport const db = drizzle(sql, { schema });\n    \n    \n"],"names":[],"mappings":";;;AACA;AACA;AACA;;;;AAEA,MAAM,MAAM,CAAA,GAAA,sJAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,GAAG,CAAC,YAAY;AAClC,MAAM,KAAK,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,KAAK;IAAE,QAAA;AAAO","debugId":null}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/booking/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport {\n  verifyPaymentProof,\n} from \"@/ai/flows/verify-payment-proof\";\nimport { db } from \"@/lib/db\";\nimport { bookings } from \"@/lib/schema\";\nimport { eq } from \"drizzle-orm\";\nimport { z } from \"zod\";\n\n\nconst CreateBookingInputSchema = z.object({\n  ownerFullName: z.string().min(1, \"Full name is required\"),\n  ownerMobile: z.string().regex(/^[6-9]\\d{9}$/, \"Invalid mobile number\"),\n  ownerEmail: z.string().email(\"Invalid email address\"),\n  ownerAadhaar: z.string().regex(/^\\d{12}$/, \"Invalid Aadhaar number\"),\n  ownerAddress: z.string().min(1, \"Address is required\"),\n  ownerState: z.string().min(1, \"State is required\"),\n  ownerPincode: z.string().regex(/^\\d{6}$/, \"Invalid PIN code\"),\n  vehicleRegistrationNumber: z.string().min(1, \"Vehicle registration number is required\"),\n  engineNumber: z.string().min(1, \"Engine number is required\"),\n  chassisNumber: z.string().min(1, \"Chassis number is required\"),\n  vehicleMake: z.string().min(1, \"Vehicle make is required\"),\n  vehicleModel: z.string().min(1, \"Vehicle model is required\"),\n  manufacturingYear: z.string().min(1, \"Manufacturing year is required\"),\n  selectedCategory: z.string(),\n  totalAmount: z.number(),\n});\n\n\nexport async function createBooking(input: z.infer<typeof CreateBookingInputSchema>) {\n  const validation = CreateBookingInputSchema.safeParse(input);\n\n  if (!validation.success) {\n    return {\n      success: false,\n      error: \"Invalid input data.\",\n      issues: validation.error.issues,\n    };\n  }\n  \n  const { selectedCategory, totalAmount, ...bookingData } = validation.data;\n  const newOrderId = `HSRP-${Date.now()}`;\n  \n  try {\n    const newBookingData = {\n      orderId: newOrderId,\n      ...bookingData,\n      vehicleCategory: selectedCategory,\n      amount: totalAmount,\n      status: 'pending',\n      verificationReason: 'Awaiting payment proof upload.'\n    };\n    \n    // Insert the booking without returning\n    await db.insert(bookings).values(newBookingData);\n    \n    // Fetch the booking we just created using the unique orderId\n    const newBooking = await db.query.bookings.findFirst({\n        where: eq(bookings.orderId, newOrderId),\n    });\n\n    if (!newBooking) {\n      throw new Error(\"Booking creation failed, could not find newly created booking.\");\n    }\n\n    return { success: true, orderId: newBooking.orderId, bookingId: newBooking.id };\n\n  } catch (error) {\n     console.error(\"Booking creation failed:\", error);\n     const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred.\";\n     return {\n       success: false,\n       error: `An unexpected error occurred during booking creation. ${errorMessage}`,\n     };\n  }\n}\n\nconst UpdateBookingWithPaymentInputSchema = z.object({\n    paymentProofUrl: z.string(),\n    orderId: z.string(),\n    bookingId: z.number(),\n    totalAmount: z.number(),\n});\n\n// Separate async function to handle the AI verification in the background.\nasync function triggerAiVerification(bookingId: number, paymentProofUrl: string, totalAmount: number, orderId: string) {\n    try {\n        const verificationResult = await verifyPaymentProof({\n            paymentProofDataUri: paymentProofUrl,\n            expectedAmount: totalAmount,\n            orderId: orderId,\n        });\n\n        const finalStatus = verificationResult.isVerified ? \"payment_verified\" : \"payment_rejected\";\n        await db.update(bookings).set({\n            status: finalStatus,\n            verificationReason: verificationResult.reason,\n            updatedAt: new Date(),\n        }).where(eq(bookings.id, bookingId));\n\n        console.log(`AI verification completed for order ${orderId}. Status: ${finalStatus}`);\n    } catch (aiError) {\n        console.error(`AI verification failed for order ${orderId}:`, aiError);\n        // Update the status to indicate a failure in the AI verification process\n        await db.update(bookings).set({\n            status: 'payment_verification_failed',\n            verificationReason: 'The AI verification process encountered an error.',\n            updatedAt: new Date(),\n        }).where(eq(bookings.id, bookingId));\n    }\n}\n\nexport async function updateBookingWithPayment(input: z.infer<typeof UpdateBookingWithPaymentInputSchema>) {\n    const { paymentProofUrl, orderId, bookingId, totalAmount } = UpdateBookingWithPaymentInputSchema.parse(input);\n    \n    try {\n        // First, update the booking with the proof and set status to pending verification\n        await db.update(bookings).set({\n            paymentProof: paymentProofUrl,\n            status: 'payment_pending_verification',\n            verificationReason: 'Payment proof uploaded. Awaiting AI verification.',\n            updatedAt: new Date(),\n        }).where(eq(bookings.id, bookingId));\n\n        // Trigger AI verification in the background (fire and forget)\n        triggerAiVerification(bookingId, paymentProofUrl, totalAmount, orderId);\n\n        return { success: true };\n\n    } catch (error) {\n        console.error(\"Error during booking update:\", error);\n        const errorMessage = error instanceof Error ? error.message : \"An unknown error occurred.\";\n        return { success: false, error: `Failed to update booking. ${errorMessage}` };\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 572, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/booking/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {createBooking as '4052ab6733676dd6ec71105b170626f6ca0dcc452b'} from 'ACTIONS_MODULE0'\nexport {updateBookingWithPayment as '40555d556b53b0cda4ba3f836ad5f0f249037d6e35'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/booking/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/booking/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/booking/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA4R,GACzT,0DACA","debugId":null}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/booking/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/booking/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/booking/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAwQ,GACrS,sCACA","debugId":null}},
    {"offset": {"line": 661, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}